# Laboratorio-DOSW-02

# Maratón Git 2025-2

** Integrantes :**
-  Sofia Nicolle Ariza Goenaga
-  Tomas Felipe Ramirez Alvarez

** Nombre de la rama :** feature/RamirezTomas_ArizaSofia_2025-2

## Retos Completados

### Reto 1: Configuración y creación de rama
** Evidencia :**

Hicimos un desarrollo de clases de las estudiantes y la clase que imprime el mensaje el cual es redactado lógicamente
atravez de mensajes y organizar la información para imprimirlo correctamente dando una solución óptima para la clase
![img_6.png](img_6.png)
Lo que se planeo hacer fue una "plantilla" que convirtiera la información de los estudiantes en un mensaje segun 
la redaccion solicitada por el problea. Conviertiendo los objetos de la lista es un flujo del que pudieramos 
extraer de manera relativamente eficiente los atributos especificos.

### Reto 2: Commit colaborativo
** Evidencia :**
![img_3 (2).png](img_3%20%282%29.png)
En este reto nos dismos a la intervencion rigurosa de cada una de las reglas para hacer su desarrollo
lo mas claro,consiso y limpio al momento de detallar tanto visual como logicamente el codigo presentado 
el cual atravez de clases y metodos se desarrollo el ejercicio del punto 2 de manera correcta, se evidencian
en los pantallasos los procesos para llegar a su etapa final.
![img_1 (2).png](img_1%20%282%29.png)
En la siguiente se puede apreciar como se evidencian los choques propuestos en el ejercicio 
![img_2 (2).png](img_2%20%282%29.png)
Después de las rigurosas pruevas y creacion de una nueva clase solicitada para el resultado final asi se 
aprecia su trabajo en totalidad de los requerimientos solicitados
Con el fin de dar solucion a cada una de las incopnitas propuestas en este reto la ultima pregunta es alucion
a usar el comando "git log --oneline"
![img_4 (2).png](img_4%20%282%29.png)

### Reto 3: El eco misterioso
** Evidencia :**
Cada uno de los miembros del equipo creo su propia rama y creo los metodos correspondientes al primer punto.
Para repetir el mensaje recibido, se creo una funcion que devolvia una funcion lambda compuesta de la siguiente manera.
Stream para generar un ciclo que se repitiera tres veces. Por cada iteracion se agregaria el mensaje en el stringBuilder, 
sin embargo, se agrego una verificacion para saber cuando era necesario añadir o no añadir un espacio intermedio.
![img_7.png](img_7.png)
Para el reverse fue mucho más sencillo y solo se utilizó la funcion reverse de la clase buffer.
![img_8.png](img_8.png)
Cada uno mergeo cada rama individual en la principal del reto, y se solucionaron los conflictos para llegar al resultado 
final en el que se utilizaban las funciones anteriores en pro del último paso.
![img_9.png](img_9.png)


### Reto 6: La maquina de desiciones
** Evidencia :**
Para empezar cada miembro del equipo en una rama separada creo el respectivo switch con cada parte de las instrucciones.
![img_3.png](img_3.png)
![img_4.png](img_4.png)
Luego se hicieron los merge a la rama feature del reto, y se resolvieron los conflictos.
![img_5.png](img_5.png)
![img_2.png](img_2.png)
al final, despues de resolver los conflictos obtuvimos.
![img_1.png](img_1.png)
Dada esta máquina de decisiones, nos propusimos cumplir con el segundo requirimiento, cambiando los llamados repetitivos,
por una estructura de for que guardaba en un map el nombre de la accion y su runnable. En el mismo ciclo quisimos llamar
los runnables para verificar que funcionaba de manera correcta sin añadir mas lineas de codigo. Se añadio una accion 
adicional fuera del bucle para terminar de verificar que todo funcionaba correctamente.
![img.png](img.png)
## Preguntas teóricas